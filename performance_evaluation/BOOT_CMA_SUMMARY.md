# Boot / CMA summary (concise)

Date: 2025-11-25

Summary
- You previously added a `cma=` kernel parameter but edited the wrong file. On modern Raspberry Pi images the live boot config is on the *boot partition* (when running: `/boot/firmware/cmdline.txt`). When inspecting the offline root filesystem you saw a helper file at `/boot/cmdline.txt` that contains the text "DO NOT EDIT THIS FILE" and points to `/boot/firmware`.
- The real boot partition is mounted at `/media/gregm/bootfs` on your rescue system. The real, effective file is `/media/gregm/bootfs/cmdline.txt` (or `/boot/firmware/cmdline.txt` on a running system).

What went wrong
- The `cma=2048M` change was appended to the fake `/media/gregm/rootfs/boot/cmdline.txt` (the "DO NOT EDIT" file) so the bootloader never saw it.
- A later edit to set `cma=1024M` apparently made the system unbootable. Common causes:
  - `cmdline.txt` must be a single line. If a newline was inserted when editing, the kernel can fail to parse the command line and the system will fail early (symptoms like `hctosys: unable to read the hardware clock` are commonly seen when boot stalls early).
  - Note about "zero lines": a file can contain the full cmdline text yet lack a trailing newline character. Tools like `wc -l` count newline characters and will report 0 lines for such files. A missing trailing newline can produce the exact behaviour you observed (the edit appears in the file when viewed, but the bootloader/kernel may not parse it correctly). Always ensure the cmdline file ends with a single newline.
  - A too-large CMA or incorrect value can also cause memory/resource issues during boot; but in your case the primary problem was likely editing the wrong file or introducing a newline.

Immediate recovery steps (succinct)
1. On the rescue machine, edit the real boot file and remove any `cma=` entries:

```bash
sudo cp /media/gregm/bootfs/cmdline.txt /media/gregm/bootfs/cmdline.txt.bak
sudo nano /media/gregm/bootfs/cmdline.txt
# ensure the file is exactly one line; remove any `cma=...` tokens
```

2. Clean the fake helper file so it doesn't mislead later:

```bash
sudo sed -i 's/ cma=[^[:space:]]\+//g' /media/gregm/rootfs/boot/cmdline.txt
```

3. Reboot the target device from its normal boot path. If it boots, verify:

```bash
# check the kernel cmdline seen by the running system
cat /proc/cmdline

# check CMA totals
egrep -i 'CmaTotal|CmaFree' /proc/meminfo

# check AXCL device and CMM usage
axcl-smi info --cmm -d 0
```

Re-applying CMA safely
- When the system is booted normally, edit `/boot/firmware/cmdline.txt` (this is the live path) and append a single token such as ` cma=2048M` if you need ~2GiB reserved. Important: keep `cmdline.txt` exactly one line. Do not insert newlines.
- If 2GiB reserves too much RAM for normal use, try `cma=1536M` (or test `1024M`) but verify the model actually fits: your traces indicated the model required ~1.8GiB contiguous memory, so 2GiB is the safe value.

Checks to avoid repeat errors
- Always edit the boot partition file (when offline it's `/media/gregm/bootfs/cmdline.txt`).
- Verify the file is one line: `wc -c /media/gregm/bootfs/cmdline.txt` (should report a single line length, not multiple lines) or `tr -d '\n' < /media/gregm/bootfs/cmdline.txt | wc -c`.
- Keep a backup before changing: `sudo cp /media/gregm/bootfs/cmdline.txt{,.bak}`.

Notes
- The `hctosys: unable to read the hardware clock` message is usually a symptom of an early boot failure and not the root cause here. Fix `cmdline.txt` (single-line, correct file) first, then revisit CMA sizing.

Short-term recommendation
- Restore a clean `cmdline.txt` (no `cma=`) so the device boots reliably. Then, while local and able to watch the console, add `cma=2048M` to `/boot/firmware/cmdline.txt` and reboot to test the NPU runtime.
 
**Device Tree overlay installed**
- Where: `performance_evaluation/cma-2g.dts` (source) and `performance_evaluation/cma-2g.dtbo` (compiled) were created. The DTBO was copied to `/boot/firmware/overlays/cma-2g.dtbo` and `dtoverlay=cma-2g` was added to `/boot/firmware/config.txt`.

**Undo / Safe-boot instructions**
If anything goes wrong after enabling the overlay (or you need to recover the system from external media), follow these steps to safely undo the overlay and restore the previous boot state.

1) Boot from rescue media (USB / SD) and mount the target device's boot partition

```bash
# Example device nodes; adjust if your boot partition is different
sudo mkdir -p /mnt/target_boot
sudo mount /dev/mmcblk0p1 /mnt/target_boot    # common on Raspberry Pi
# or, if using the mounted rescue path used earlier:
sudo mount /media/gregm/bootfs /mnt/target_boot
```

2) Back up current boot files (do this first)

```bash
sudo cp -a /mnt/target_boot/cmdline.txt /mnt/target_boot/cmdline.txt.bak
sudo cp -a /mnt/target_boot/config.txt /mnt/target_boot/config.txt.bak
sudo cp -a /mnt/target_boot/overlays/cma-2g.dtbo /mnt/target_boot/overlays/cma-2g.dtbo.bak || true
```

3) Remove overlay enable line from `config.txt` (idempotent)

```bash
sudo sed -i '/^dtoverlay=cma-2g\b/d' /mnt/target_boot/config.txt
# verify single-line integrity of cmdline.txt remains
wc -l /mnt/target_boot/cmdline.txt
```

4) Remove the DTBO from overlays (optional; safer to keep backup)

```bash
sudo rm -f /mnt/target_boot/overlays/cma-2g.dtbo
# or move it aside so you can restore quickly
sudo mv /mnt/target_boot/overlays/cma-2g.dtbo /mnt/target_boot/overlays/cma-2g.dtbo.disabled
```

5) Ensure `cmdline.txt` is single-line and does not contain any `cma=` tokens

```bash
# remove any cma= tokens if present
sudo sed -i 's/ cma=[^[:space:]]\+//g' /mnt/target_boot/cmdline.txt
tr -d '\n' < /mnt/target_boot/cmdline.txt | wc -c   # should print nonzero length on one line
```

6) Unmount and reboot from the device's normal boot medium

```bash
sudo umount /mnt/target_boot
# reboot the device normally (from SD/eMMC)
```

7) If the system still fails to boot, restore the exact backups created in step (2)

```bash
# from your rescue environment, remount the boot partition and then
sudo cp -a /mnt/target_boot/cmdline.txt.bak /mnt/target_boot/cmdline.txt
sudo cp -a /mnt/target_boot/config.txt.bak /mnt/target_boot/config.txt
sudo mv /mnt/target_boot/overlays/cma-2g.dtbo.bak /mnt/target_boot/overlays/cma-2g.dtbo || true
sudo umount /mnt/target_boot
```

Notes and safety tips
- Always make a backup copy of `cmdline.txt` and `config.txt` before editing. `cmdline.txt` must remain a single line.
- Prefer editing the boot partition while the card is offline (mounted on a rescue machine) to avoid accidental newline insertion by editors.
- If you need a smaller CMA to test, remove the overlay and instead test `cma=1024M` in `/boot/firmware/cmdline.txt` (carefully, ensuring the file remains one line) and reboot.
- Keep the generated `performance_evaluation/cma-2g.dts` and `*.dtbo` files in the repo for auditing; they are safe to keep under `/boot/firmware/overlays/` if you want to re-enable the overlay later.

**Conservative CMA Test (cma=256M)**
To verify if the CMA parameter mechanism works at all without risking boot failure, test with a small, safe value (256MB). This is larger than the default 64MB but small enough to avoid allocation issues.

### Step 1: Ensure Overlay is Disabled
First, make sure we aren't still trying to load the failed overlay.

```bash
# Remove the overlay line if it exists
sudo sed -i '/^dtoverlay=cma-2g/d' /boot/firmware/config.txt
```

### Step 2: Apply Conservative CMA (256M)
We will use a strict `sed` command to append the parameter without adding newlines.

```bash
# 1. Clean out any existing cma= entries to avoid duplicates
sudo sed -i 's/ cma=[^[:space:]]*//g' /boot/firmware/cmdline.txt

# 2. Append cma=256M safely
sudo sed -i 's/$/ cma=256M/' /boot/firmware/cmdline.txt

# 3. Verify it is still exactly one line (output should be "1")
wc -l /boot/firmware/cmdline.txt
```

### Step 3: Reboot and Verify
Reboot the system.

```bash
sudo reboot
```

**After reboot:**
Check if the system accepted the value:
```bash
grep CmaTotal /proc/meminfo
```
*   **Success:** You see `CmaTotal: 262144 kB` (approx 256MB). This proves the mechanism works.
*   **Failure (Boot loop):** The issue is the file editing process/syntax.
*   **Failure (Still 64MB):** The kernel is ignoring the parameter (firmware override).
