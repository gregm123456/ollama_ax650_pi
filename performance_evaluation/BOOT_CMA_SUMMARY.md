# Boot / CMA summary (concise)

Date: 2025-11-25

Summary
- You previously added a `cma=` kernel parameter but edited the wrong file. On modern Raspberry Pi images the live boot config is on the *boot partition* (when running: `/boot/firmware/cmdline.txt`). When inspecting the offline root filesystem you saw a helper file at `/boot/cmdline.txt` that contains the text "DO NOT EDIT THIS FILE" and points to `/boot/firmware`.
- The real boot partition is mounted at `/media/gregm/bootfs` on your rescue system. The real, effective file is `/media/gregm/bootfs/cmdline.txt` (or `/boot/firmware/cmdline.txt` on a running system).

What went wrong
- The `cma=2048M` change was appended to the fake `/media/gregm/rootfs/boot/cmdline.txt` (the "DO NOT EDIT" file) so the bootloader never saw it.
- A later edit to set `cma=1024M` apparently made the system unbootable. Common causes:
  - `cmdline.txt` must be a single line. If a newline was inserted when editing, the kernel can fail to parse the command line and the system will fail early (symptoms like `hctosys: unable to read the hardware clock` are commonly seen when boot stalls early).
  - A too-large CMA or incorrect value can also cause memory/resource issues during boot; but in your case the primary problem was likely editing the wrong file or introducing a newline.

Immediate recovery steps (succinct)
1. On the rescue machine, edit the real boot file and remove any `cma=` entries:

```bash
sudo cp /media/gregm/bootfs/cmdline.txt /media/gregm/bootfs/cmdline.txt.bak
sudo nano /media/gregm/bootfs/cmdline.txt
# ensure the file is exactly one line; remove any `cma=...` tokens
```

2. Clean the fake helper file so it doesn't mislead later:

```bash
sudo sed -i 's/ cma=[^[:space:]]\+//g' /media/gregm/rootfs/boot/cmdline.txt
```

3. Reboot the target device from its normal boot path. If it boots, verify:

```bash
# check the kernel cmdline seen by the running system
cat /proc/cmdline

# check CMA totals
egrep -i 'CmaTotal|CmaFree' /proc/meminfo

# check AXCL device and CMM usage
axcl-smi info --cmm -d 0
```

Re-applying CMA safely
- When the system is booted normally, edit `/boot/firmware/cmdline.txt` (this is the live path) and append a single token such as ` cma=2048M` if you need ~2GiB reserved. Important: keep `cmdline.txt` exactly one line. Do not insert newlines.
- If 2GiB reserves too much RAM for normal use, try `cma=1536M` (or test `1024M`) but verify the model actually fits: your traces indicated the model required ~1.8GiB contiguous memory, so 2GiB is the safe value.

Checks to avoid repeat errors
- Always edit the boot partition file (when offline it's `/media/gregm/bootfs/cmdline.txt`).
- Verify the file is one line: `wc -c /media/gregm/bootfs/cmdline.txt` (should report a single line length, not multiple lines) or `tr -d '\n' < /media/gregm/bootfs/cmdline.txt | wc -c`.
- Keep a backup before changing: `sudo cp /media/gregm/bootfs/cmdline.txt{,.bak}`.

Notes
- The `hctosys: unable to read the hardware clock` message is usually a symptom of an early boot failure and not the root cause here. Fix `cmdline.txt` (single-line, correct file) first, then revisit CMA sizing.

Short-term recommendation
- Restore a clean `cmdline.txt` (no `cma=`) so the device boots reliably. Then, while local and able to watch the console, add `cma=2048M` to `/boot/firmware/cmdline.txt` and reboot to test the NPU runtime.
